## 技术规范：基于音象征分类的音素加权采样算法

### 1. 概述

针对同一音素可能同时隶属于多个音象征分类的情况，定义一种“单次放大并归一化”方法，通过计算各分类的放大因子（boost factor），对音素权重进行加权叠加，最后统一归一化得到采样概率。

### 2. 术语与符号

* **$\mathcal{X}$**: 全部音素集合。
* **$w_0(x)$**: 音素 $x$ 的基础权重，$\sum_{x\in\mathcal{X}} w_0(x)=1$。通常均匀分布或预定义分布。
* **分类集合**: $\{c_1,c_2,\dots,c_m\}$。
* **$S_{c}\subseteq \mathcal{X}$**: 分类 $c$ 对应的音素子集。
* **目标边缘概率 $T_c$**: 希望在采样分布中，落在 $S_c$ 内的音素总概率。
* **基础边缘质量 $M_c$**:
  $M_c = \sum_{x\in S_c} w_0(x).$
* **放大因子 $b_c$**: 调整后，分类总质量从 $M_c$ 变为 $T_c$ 时的比例系数：
  $b_c = \frac{T_c/(1-T_c)}{M_c/(1-M_c)}.$

### 3. 算法步骤

1. **初始化**

   * 输入: 音素集合 $\mathcal{X}$，基础权重 $w_0(x)$，分类定义 $\{S_c,T_c\}$。
2. **计算基础边缘质量**

   * 对每个分类 $c$，计算
     $M_c = \sum_{x\in S_c} w_0(x).$
3. **计算放大因子**

   * 对每个分类 $c$，计算
     $b_c = \frac{T_c/(1-T_c)}{M_c/(1-M_c)}.$
4. **加权叠加**

   * 对每个音素 $x\in\mathcal{X}$，令
     $w'(x) = w_0(x) \times \prod_{c:\,x\in S_c} b_c.$
5. **归一化**

   * 计算归一化常数
     $Z = \sum_{y\in\mathcal{X}} w'(y).$
   * 得到最终采样概率
     $p(x) = \frac{w'(x)}{Z}.$

### 4. 伪代码示例

```python
# 输入
phonemes = list of all phonemes
w0 = {x: uniform_weight for x in phonemes}
categories = {c: set_of_phonemes for each c}
T = {c: target_margin for each c}

# 1. 计算 M_c
M = {c: sum(w0[x] for x in S_c) for c, S_c in categories.items()}

# 2. 计算 b_c
b = {c: (T[c]/(1-T[c])) / (M[c]/(1-M[c])) for c in categories}

# 3. 计算叠加权重 w'
w_prime = {}
for x in phonemes:
    weight = w0[x]
    for c, S_c in categories.items():
        if x in S_c:
            weight *= b[c]
    w_prime[x] = weight

# 4. 归一化得到 p(x)
Z = sum(w_prime.values())
p = {x: w_prime[x]/Z for x in phonemes}
```

### 5. 注意事项

* **基础分布**: 可根据语言需求设为均匀或按实际频率给定。
* **边缘目标**: 应保证所有 $T_c$ 在 $(0,1)$ 区间，且分类重叠度不致过高，否则单次放大近似效果可能偏差。
* **扩展**: 若需精确命中多个分类的边缘约束，可考虑迭代比例拟合（IPF）。
